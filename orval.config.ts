import { defineConfig } from "orval";

export default defineConfig({
  api: {
    output: {
      mode: "single",
      target: "services/api/index.ts",
      client: "swr",
      override: {
        mutator: {
          path: "services/api/fetcher.ts",
          name: "orvalFetcher",
        },
        query: {
          useQuery: true,
          useInfinite: false,
          signal: true,
        },
        header: (info) => [
          "Generated by orval ğŸº",
          "Do not edit manually.",
          `OpenAPI spec version: ${info.version}`,
          "",
        ],
      },
    },
    input: {
      target: "https://api.gaas.waterballsa.tw/swagger-ui/api-docs",
      validation: false,
      override: {
        transformer: (spec: any) => {
          // è¦éæ¿¾çš„åƒæ•¸åç¨±å’Œ schema
          const unwantedParams = ["jwt", "principal"];
          const unwantedSchemas = ["Jwt", "JwtHeaders", "JwtClaims"];

          // éè¿´æ¸…ç† schema ä¸­çš„å±¬æ€§
          const cleanSchema = (schema: any): any => {
            if (!schema || typeof schema !== "object") return schema;

            // è™•ç† $ref å¼•ç”¨
            if (
              schema.$ref &&
              unwantedSchemas.some((name) => schema.$ref.includes(name))
            ) {
              return undefined;
            }

            if (schema.properties) {
              const newProperties = { ...schema.properties };
              unwantedParams.forEach((param) => {
                delete newProperties[param];
              });
              schema.properties = newProperties;

              if (schema.required) {
                schema.required = schema.required.filter(
                  (prop: string) => !unwantedParams.includes(prop)
                );
                if (schema.required.length === 0) {
                  delete schema.required;
                }
              }
            }

            // è™•ç†åµŒå¥—çµæ§‹
            if (schema.items) {
              const cleanedItems = cleanSchema(schema.items);
              if (cleanedItems !== undefined) {
                schema.items = cleanedItems;
              } else {
                delete schema.items;
              }
            }

            if (schema.allOf) {
              schema.allOf = schema.allOf
                .map(cleanSchema)
                .filter((s: any) => s !== undefined);
            }

            if (schema.oneOf) {
              schema.oneOf = schema.oneOf
                .map(cleanSchema)
                .filter((s: any) => s !== undefined);
            }

            if (schema.anyOf) {
              schema.anyOf = schema.anyOf
                .map(cleanSchema)
                .filter((s: any) => s !== undefined);
            }

            return schema;
          };

          // æ¸…ç† components/schemas
          if (spec.components?.schemas) {
            // ç§»é™¤ä¸éœ€è¦çš„ schema
            unwantedSchemas.forEach((schemaName) => {
              delete spec.components.schemas[schemaName];
            });

            // æ¸…ç†å…¶ä»– schema ä¸­çš„å±¬æ€§
            Object.keys(spec.components.schemas).forEach((key) => {
              spec.components.schemas[key] = cleanSchema(
                spec.components.schemas[key]
              );
            });
          }

          // æ¸…ç† paths ä¸­çš„æ“ä½œ
          if (spec.paths) {
            Object.keys(spec.paths).forEach((pathKey) => {
              const pathItem = spec.paths[pathKey];
              Object.keys(pathItem).forEach((method) => {
                const operation = pathItem[method];
                if (!operation || typeof operation !== "object") return;

                // ç§»é™¤ä¸éœ€è¦çš„åƒæ•¸
                if (operation.parameters) {
                  operation.parameters = operation.parameters.filter(
                    (param: any) => !unwantedParams.includes(param.name)
                  );
                }

                // æ¸…ç† requestBody
                if (operation.requestBody?.content) {
                  Object.keys(operation.requestBody.content).forEach(
                    (contentType) => {
                      const content =
                        operation.requestBody.content[contentType];
                      if (content.schema) {
                        content.schema = cleanSchema(content.schema);
                      }
                    }
                  );
                }

                // æ¸…ç† responses
                if (operation.responses) {
                  Object.keys(operation.responses).forEach((statusCode) => {
                    const response = operation.responses[statusCode];
                    if (response?.content) {
                      Object.keys(response.content).forEach((contentType) => {
                        const content = response.content[contentType];
                        if (content.schema) {
                          content.schema = cleanSchema(content.schema);
                        }
                      });
                    }
                  });
                }

                // ç‰¹æ®Šè™•ç†ï¼šç§»é™¤æ“ä½œä¸­ç›´æ¥ä½¿ç”¨ JWT ä½œç‚º requestBody çš„æƒ…æ³
                if (
                  operation.requestBody?.content?.[
                    "application/json"
                  ]?.schema?.$ref?.includes("Jwt")
                ) {
                  delete operation.requestBody;
                }
              });
            });
          }

          return spec;
        },
      },
    },
    hooks: {
      afterAllFilesWrite: "prettier --write services/api/index.ts",
    },
  },
});
