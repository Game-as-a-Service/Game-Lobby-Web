import { defineConfig } from "orval";

export default defineConfig({
  api: {
    output: {
      mode: "single",
      target: "services/api/index.ts",
      client: "swr",
      override: {
        mutator: {
          path: "services/api/fetcher.ts",
          name: "orvalFetcher",
        },
        query: {
          useQuery: true,
          useInfinite: false,
          signal: true,
        },
        header: (info) => [
          "Generated by orval ğŸº",
          "Do not edit manually.",
          `OpenAPI spec version: ${info.version}`,
          "",
        ],
      },
    },
    input: {
      target: "https://api.gaas.waterballsa.tw/swagger-ui/api-docs",
      validation: false,
      override: {
        transformer: (spec: any) => {
          // è¦éæ¿¾çš„åƒæ•¸åç¨±å’Œ schema
          const unwantedParams = ["jwt", "principal"];
          const unwantedSchemas = ["Jwt", "JwtHeaders", "JwtClaims"];

          // éè¿´æ¸…ç† schema ä¸­çš„å±¬æ€§
          const cleanSchema = (schema: any): any => {
            if (!schema || typeof schema !== "object") return schema;

            // è™•ç† $ref å¼•ç”¨
            if (
              schema.$ref &&
              unwantedSchemas.some((name) => schema.$ref.includes(name))
            ) {
              return undefined;
            }

            if (schema.properties) {
              const newProperties = { ...schema.properties };

              // ç§»é™¤ä¸éœ€è¦çš„åƒæ•¸
              unwantedParams.forEach((param) => {
                delete newProperties[param];
              });

              // è™•ç† request å±¬æ€§æå‡
              if (newProperties.request) {
                // æª¢æŸ¥æ˜¯å¦åªæœ‰ request å±¬æ€§ï¼ˆæˆ–è€…åŠ ä¸Šä¸€äº›å·²è¢«ç§»é™¤çš„ unwanted paramsï¼‰
                const remainingKeys = Object.keys(newProperties);
                const onlyHasRequest =
                  remainingKeys.length === 1 && remainingKeys[0] === "request";

                if (onlyHasRequest) {
                  // æƒ…æ³1: request æœ‰ propertiesï¼ˆåµŒå¥—ç‰©ä»¶ï¼‰
                  if (newProperties.request.properties) {
                    // æ¸…ç©ºç¾æœ‰å±¬æ€§ï¼Œç”¨ request çš„å±¬æ€§æ›¿ä»£
                    schema.properties = newProperties.request.properties;

                    // è™•ç† required å±¬æ€§
                    if (newProperties.request.required) {
                      schema.required = newProperties.request.required;
                    } else {
                      delete schema.required;
                    }
                  }
                  // æƒ…æ³2: request æ˜¯ $ref å¼•ç”¨
                  else if (newProperties.request.$ref) {
                    // ç›´æ¥å°‡ schema æ›¿æ›ç‚ºå¼•ç”¨çš„å…§å®¹
                    return newProperties.request;
                  }

                  return schema;
                }
              }

              schema.properties = newProperties;

              if (schema.required) {
                schema.required = schema.required.filter(
                  (prop: string) => !unwantedParams.includes(prop)
                );
                if (schema.required.length === 0) {
                  delete schema.required;
                }
              }
            }

            // è™•ç†åµŒå¥—çµæ§‹
            if (schema.items) {
              const cleanedItems = cleanSchema(schema.items);
              if (cleanedItems !== undefined) {
                schema.items = cleanedItems;
              } else {
                delete schema.items;
              }
            }

            if (schema.allOf) {
              schema.allOf = schema.allOf
                .map(cleanSchema)
                .filter((s: any) => s !== undefined);
            }

            if (schema.oneOf) {
              schema.oneOf = schema.oneOf
                .map(cleanSchema)
                .filter((s: any) => s !== undefined);
            }

            if (schema.anyOf) {
              schema.anyOf = schema.anyOf
                .map(cleanSchema)
                .filter((s: any) => s !== undefined);
            }

            return schema;
          };

          // æ¸…ç† components/schemas
          if (spec.components?.schemas) {
            // ç§»é™¤ä¸éœ€è¦çš„ schema
            unwantedSchemas.forEach((schemaName) => {
              delete spec.components.schemas[schemaName];
            });

            // æ¸…ç†å…¶ä»– schema ä¸­çš„å±¬æ€§
            Object.keys(spec.components.schemas).forEach((key) => {
              spec.components.schemas[key] = cleanSchema(
                spec.components.schemas[key]
              );
            });
          }

          // æ¸…ç† paths ä¸­çš„æ“ä½œ
          if (spec.paths) {
            Object.keys(spec.paths).forEach((pathKey) => {
              const pathItem = spec.paths[pathKey];
              Object.keys(pathItem).forEach((method) => {
                const operation = pathItem[method];
                if (!operation || typeof operation !== "object") return;

                // ç§»é™¤ä¸éœ€è¦çš„åƒæ•¸
                if (operation.parameters) {
                  operation.parameters = operation.parameters.filter(
                    (param: any) => !unwantedParams.includes(param.name)
                  );
                }

                // æ¸…ç† requestBody
                if (operation.requestBody?.content) {
                  Object.keys(operation.requestBody.content).forEach(
                    (contentType) => {
                      const content =
                        operation.requestBody.content[contentType];
                      if (content.schema) {
                        content.schema = cleanSchema(content.schema);
                      }
                    }
                  );
                }

                // æ¸…ç† responses
                if (operation.responses) {
                  Object.keys(operation.responses).forEach((statusCode) => {
                    const response = operation.responses[statusCode];
                    if (response?.content) {
                      Object.keys(response.content).forEach((contentType) => {
                        const content = response.content[contentType];
                        if (content.schema) {
                          content.schema = cleanSchema(content.schema);
                        }
                      });
                    }
                  });
                }

                // ç‰¹æ®Šè™•ç†ï¼šç§»é™¤æ“ä½œä¸­ç›´æ¥ä½¿ç”¨ JWT ä½œç‚º requestBody çš„æƒ…æ³
                if (
                  operation.requestBody?.content?.[
                    "application/json"
                  ]?.schema?.$ref?.includes("Jwt")
                ) {
                  delete operation.requestBody;
                }
              });
            });
          }

          return spec;
        },
      },
    },
    hooks: {
      afterAllFilesWrite: "prettier --write services/api/index.ts",
    },
  },
});
